--- 分类数据查询
---1.先查询nginx缓存，如果有直接返回，没有进入2
---2.查询redis，如果有返回，且写入到nginx缓存中，没有数据进入3
---3.查询mysql数据库，如果有数据返回，且写入到redis
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by huang.
--- DateTime: 16/09/2023 15:46
---
ngx.header.content_type = "application/json;charset=utf8"
local uri_args = ngx.req.get_uri_args();
local id = uri_args["id"];

-- nginx 缓存
-- 这里的名字和nginx.conf配置文件的
-- lua_shared_dict dis_cache 128m;
-- 名称有关
local cache_ngx = ngx.shared.dis_cache_hh;
local contentCache = cache_ngx:get('content_cache_' .. id);
-- 非空判断，~=表示不等于
if contentCache ~= nil then
    ngx.say("nginx data: " .. contentCache)
else
    ngx.say("nginx cache data is nil")
end
if contentCache == "" or contentCache == nil then
    -- nginx缓存为空要查询redis
    local redis = require("resty.redis");
    local red = redis:new();
    red:set_timeout(2000);
    red:connect("192.168.220.110", 6379);
    local res_content = red:get("content_" .. id);
    if ngx.null == res_content then
        --redis为空，需要查询mysql
        local cjson = require("cjson");
        local mysql = require("resty.mysql");
        local db = mysql:new();
        --db:set_timeout(1000);
        local props = {
            host = "192.168.220.110",
            port = 3306,
            -- 数据库名
            database = "legou",
            user = "root",
            password = "root"
        }
        local res = db:connect(props);
        local select_sql = "select id_, is_parent_, order_, parent_id_, title_, expand_ from category_ where id_ = " .. id;
        res = db:query(select_sql);
        local response_json = cjson.encode(res);
        red:set("content_" .. id, response_json);
        ngx.say("mysql data: " .. response_json);
        db:close();
    else
        -- redis 有数据，塞进nginx即可
        cache_ngx:set("content_cache_" .. id, res_content, 10 * 60);
        ngx.say("redis data: " .. res_content);
    end
    red:close();
else
    -- nginx缓存就有数据，直接返回
    ngx.say("function over.nginx data: " .. contentCache);
end